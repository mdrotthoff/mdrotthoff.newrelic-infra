#!/usr/bin/env python

# File: check_linux_metrics.py
# URL: https://github.com/kxr/check_linux_metrics
# Author: Khizer Naeem 
# Email: khizernaeem@gmail.com
# Release 0.1: 20/05/2015
# Release 0.2: 02/06/2015
# Release 0.3: 16/07/2015
# Release 0.3.1: 06/10/2015
# Release 0.3.2: 31/01/2016
# Release 0.3.3: 16/03/2016
# Release 0.4.3: 22/08/2017
# 
#
#  Copyright (c) 2015 Khizer Naeem (http://kxr.me)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#  Local vAuto enhancements by david.rotthoff@vauto.com
#  2015.09.30  Added enhancement to split the standard network check into two different
#              complements -- one for bandwidth monitoring, the other for error monitoring
#  2015.09.30  Ensured that error monitoring is calculated as errors per minute
#  2015.09.30  Cleaned up how performance data was being captured for both of the new
#              check modules
#  2015.09.30  Defined the default interim directory where current state data is stored
#              as within the standard var directory of the vAuto install
#  2015.10.06  Cleaned up and standardized the output.
#  2015.10.06  Added aggregate values to the display and performance data.
#  2016.01.26  Modified code to rebuild the interim file if it is empty
#              and return a warning status
#  2016.01.26  Modified code to not return performance values when the 
#              result is negative and return an OK status
#  2016.01.31  Modified code to return detail CPU metrics
#  2016.03.16  Modified code read and use the speed of the network
#              interface in determining whether or not the load is
#              in warning or critical state.  Also modified the code
#              to compute the percent utilization and compare to
#              provided warning and critical utilization

import sys
import time
import os
import shutil

INTERIM_DIR = '/usr/local/nagios/var/linux_metrics_vauto'
#INTERIM_DIR = '/tmp/linux_metrics_vauto'
if not os.path.exists(INTERIM_DIR):
	os.makedirs( INTERIM_DIR )

def check_cpu( warn=None, crit=None ):
	status_code = 3
	status_outp =''
	perfdata = ''

	# Verify if the interim file exists, if not create it now
	interim_file = INTERIM_DIR + '/' + 'proc_stat'
	if not os.path.isfile( interim_file ):
		shutil.copyfile( '/proc/stat', interim_file )
		print ( 'This was the first run, run again to get values' )
		sys.exit( 0 )

	# Get mtime of the interim file and calculate the sample period
	sample_period = float( time.time() - os.path.getmtime( interim_file ) )

	# Get the deltas proc stats: interimfile - procfile(now)	
	f1 = open( interim_file, 'r' )
	try:
		line1 = f1.readline()
	finally:
		f1.close()

	f2 = open( '/proc/stat', 'r' )
	try:
		line2 = f2.readline()
	finally:
		f2.close()

	if not line1:
		# Interim file not readable
		shutil.copyfile( '/proc/stat', interim_file )
		print ( 'Rebuilding missing interim file, run again to get CPU values' )
		sys.exit( 1 )

	elif not line2:
		# CPU info not found in /proc/stat
		print ( 'Plugin Error: CPU info not found in /proc/stat' )
		sys.exit( 3 )

	deltas = [int(b) - int(a) for a, b in zip(line1.split()[1:], line2.split()[1:])]
	total = sum( deltas )
	percents = [100 - (100 * (float(total - x) / total)) for x in deltas]

	if len ( percents ) >= 7:
		cpu_pcts = {
		'user': percents[0],
		'nice': percents[1],
		'system': percents[2],
		'idle': percents[3],
		'iowait': percents[4],
		'irq': percents[5],
		'softirq': percents[6]
		}

	# older kernel don't provide steal
	if len ( percents ) >= 8:
		cpu_pcts['steal'] = percents[7]
	else:
		cpu_pcts['steal'] = 0
	cpu_pcts['cpu'] = 100 - cpu_pcts['idle']
	
	if warn is not None and crit is not None:
		if float( cpu_pcts['cpu'] ) >= float( crit ):
			status_code = 2
			status_outp += '(Critical) '
		elif float( cpu_pcts['cpu'] ) >= float( warn ):
			status_code = 1
			status_outp += '(Warning) '
		else:
			status_code = 0
			status_outp += '(OK) '
	else:
		status_code = 0

	for x in [ 'cpu', 'user', 'system', 'iowait', 'nice', 'irq', 'softirq', 'steal'  ]:
		status_outp += x + ': ' + str( '%.2f' % cpu_pcts[x] ) + '% '
		perfdata += x + '=' + str( '%.2f' % cpu_pcts[x] ) + '%' 
		if warn is not None and crit is not None:
			perfdata += ';' + str(warn) + ';' + str(crit)
		perfdata += ' '
	#remove last space
	perfdata = perfdata[:-1]

	#update the interim file
	shutil.copyfile( '/proc/stat', interim_file )

	#print status_outp + '(' + perfdata + ')| ' + perfdata
	print status_outp + '[' + str( '%.2f' % sample_period ) + ' seconds]|' + perfdata
	sys.exit( status_code )

def check_load( warn=None, crit=None ):
	status_code = 3
	status_outp =''
	perfdata = ''

	f = open('/proc/loadavg', 'r')
	try:
		line = f.readline()
	finally:
		f.close()
	load_avgs = [float(x) for x in line.split()[:3]]

	load = {
	'load1':  load_avgs[0],
	'load5':  load_avgs[1],
	'load15':  load_avgs[2]
	}

	status_outp =  'Load1: ' + str( '%.2f' % load['load1'] ) + ' '
	status_outp += 'Load5: ' + str( '%.2f' % load['load5'] ) + ' '
	status_outp += 'Load15: ' + str( '%.2f' % load['load15'] )

	if warn is not None and crit is not None:
		status_code = 0
		for i in range( len( warn ) ):
			if crit[i] !='' and warn[i] !='':
				if float( load_avgs[i] ) >= float( crit[i] ):
					status_code = 2
					status_outp += ' (Critical)'
				elif float( load_avgs[i] ) >= float(warn[i] ):
					if status_code < 1:
						status_code = 1
					status_outp += ' (Warning)'
				else:
					status_outp += ' (OK)'
	else:
		status_code = 0

	seq=0
	for x in [ 'load1', 'load5', 'load15' ]:
		perfdata += x + '=' + str( '%.2f' % load[x] )
		if warn is not None and crit is not None:
			if len( warn ) >= seq+1:
				perfdata += ';' + str(warn[seq]) + ';' + str(crit[seq])
		perfdata += ' '
		seq = seq + 1
	#remove last space
	perfdata = perfdata[:-1]

	print status_outp + ' | ' + perfdata
	sys.exit( status_code )

def check_threads( warn=None, crit=None ):
	status_code = 3
	status_outp =''
	perfdata = ''

	f = open('/proc/loadavg', 'r')
	try:
		line = f.readline()
	finally:
		f.close()
	t = line.split()[3]
	threads = {
	'running': t.split('/')[0],
	'total':   t.split('/')[1]
	}

	status_outp =  'Threads: ' + t + ' '

	if warn is not None and crit is not None:
		if float( threads['running'] ) >= float( crit ):
			status_code = 2
			status_outp += ' (Critical)'
		elif float( threads['running'] ) >= float( warn ):
			status_code = 1
			status_outp += ' (Warning)'
		else:
			status_code = 0
			status_outp += ' (OK)'
	else:
		status_code = 0

	for x in [ 'running', 'total'  ]:
		perfdata += x + '=' + str( '%.2f' % float( threads[x] ) )
		if warn is not None and crit is not None and x == 'running':
			perfdata += ';' + str(warn) + ';' + str(crit)
		perfdata += ' '
	#remove last space
	perfdata = perfdata[:-1]

	print status_outp + ' | ' + perfdata
	sys.exit( status_code )

def check_openfiles( warn=None, crit=None ):
	status_code = 3
	status_outp = ''
	perfdata = ''

	f = open('/proc/sys/fs/file-nr', 'r')
	try:
		line = f.readline()
	finally:
		f.close()
	fd = [int(x) for x in line.split()]

	ofiles = {
	'open': fd[0],
	'free': fd[1],
	'total': fd[2]
	}

	status_outp = 'Open Files: ' + str( ofiles['open'] ) + ' (free: ' + str( ofiles['free'] ) + ')'

	if warn is not None and crit is not None:
		if float( ofiles['open'] ) >= float( crit ):
			status_code = 2
			status_outp += ' (Critical)'
		elif float( ofiles['open'] ) >= float( warn ):
			status_code = 1
			status_outp += ' (Warning)'
		else:
			status_code = 0
			status_outp += ' (OK)'
	else:
		status_code = 0

	for x in [ 'open', 'free' ]:
		perfdata += x + '=' + str( '%.2f' % float( ofiles[x] ) )
		if warn is not None and crit is not None and x == 'open':
			perfdata += ';' + str(warn) + ';' + str(crit)
			perfdata += ';0;' + str( ofiles['total'] )
		perfdata += ' '
	#remove last space
	perfdata = perfdata[:-1]

	print status_outp + ' | ' + perfdata
	sys.exit( status_code )


def check_procs( warn=None, crit=None ):
	status_code = 3
	status_outp =''
	perfdata = ''

	forks = 0
	# Verify if the interim file exists, if not create it now
	interim_file = INTERIM_DIR + '/' + 'proc_stat_processes'
	if not os.path.isfile( interim_file ):
		shutil.copyfile( '/proc/stat', interim_file )
		print ( 'This was the first run, run again to get values' )
		sys.exit( 0 )
	# Get mtime of the interim file and calculate the sample period
	sample_period = float( time.time() - os.path.getmtime( interim_file ) )
	# Get the deltas proc stats interimfile - procfile(now)	
	curr_forks = 0
	for file in [ '/proc/stat', interim_file ]:
		#with open( file ) as f:
		f = open( file, 'r' )
		try:
			for line in f:
				if line.startswith( 'processes ' ):
					if file == '/proc/stat':
						curr_forks = int( line.split()[1] )
					elif file == interim_file:
						forks = curr_forks - int( line.split()[1] )	
		finally:
			f.close()
	forks_ps = float ( forks / sample_period )
	states_procs = {}
	p_total = 0
	for proc_dir in os.listdir( '/proc' ):
		if proc_dir.isdigit():
			p_total += 1
			try:
				f = open( '/proc/' + proc_dir + '/stat', 'r' )
				try:
					line = f.readline().split()[1:3]
				finally:
					f.close()
			except:
				continue
			if line[1] not in states_procs:
				states_procs[ line[1] ] = []
			states_procs[ line[1] ].append( line[0] )
	p = {
	'total': p_total,
	'forks': forks_ps,
	'running': 0,
	'sleeping': 0,
	'waiting': 0,
	'zombie': 0,
	'others': 0
	}
	for state in states_procs:
		if state == 'R':
			p['running'] += len( states_procs[state] )
		elif state == 'S':
			p['sleeping'] += len( states_procs[state] )
		elif state == 'D':
			p['waiting'] += len( states_procs[state] )
		elif state == 'Z':
			p['zombie'] += len( states_procs[state] )
		else:
			p['others'] += len( states_procs[state] )

	status_outp += 'Total:' + str( p['total'] ) + ' Running:' + str( p['running'] ) + ' Sleeping:' + str( p['sleeping'] ) + ' Waiting:' + str( p['waiting'] )
	status_outp += ' Zombie:' + str( p['zombie'] ) + ' Others:' + str( p['others'] ) + ' New_Forks:' + str( '%.2f' % p['forks'] ) + '/s'

	if warn is not None and crit is not None:
		status_code = 0
		param = [ 'total', 'running', 'waiting' ]
		for i in range( len( warn ) ):
			if crit[i] != '' and warn[i] != '':
				if float( p[ param[i] ] ) >= float( crit[i] ):
					status_code = 2
					status_outp += ' (Critical ' + param[i] + ')'
				elif float( p[ param[i] ] ) >= float(warn[i] ):
					if ( status_code < 1 ):
						status_code = 1
					status_outp += ' (Warning ' + param[i] + ')'
				else:
					status_outp += ' (OK)'
	else:
		status_code = 0

	seq=0
	for x in [ 'total', 'forks', 'sleeping', 'running', 'waiting', 'zombie', 'others' ]:
		perfdata += x + '=' + str( '%.2f' % p[x] )
		if warn is not None and crit is not None:
			if x in [ 'total', 'running', 'waiting' ]:
				if len( warn ) >= seq+1:
					perfdata += ';' + str(warn[seq]) + ';' + str(crit[seq])
					seq = seq + 1
	
		perfdata += ' '
	#remove last space
	perfdata = perfdata[:-1]

	#update the interim file
	shutil.copyfile( '/proc/stat', interim_file )

	print status_outp + ' | ' + perfdata
	sys.exit( status_code )

def check_diskio( dev, warn=None, crit=None ):
	status_code = 3
	status_outp =''
	perfdata = ''

	#Process the device
	if dev.startswith( '/' ):
		real_path = os.path.realpath( dev )
		if str( real_path[:5] ) != '/dev/':
			print ( 'Plugin Error: Block device not found: ' + real_path + '('+device+')' )
			sys.exit( 3 )
		else:
			device = real_path [5:]
	else:
		device = dev

	#Check if the device exist
	f2 = open( '/proc/diskstats', 'r' )
	try:
		proc_content = f2.read()
	finally:
		f2.close()
	sep = '%s ' % device
	found = False
	for line in proc_content.splitlines():
		if sep in line:
			found = True
			proc_line = line.strip().split(sep)[1].split()
			break
	if not found:
		print ( 'Plugin Error: Block device not found: ('+device+')' )
		sys.exit( 3 )
	else:
		#Now the the device is found:
		#Verify if the interim file exists, if not create it now
		interim_file = INTERIM_DIR + '/' + 'proc_diskstats_' + str(device).replace( '/', '_' )
		if not os.path.isfile( interim_file ):
			shutil.copyfile( '/proc/diskstats', interim_file )
			print ( 'This was the first run, run again to get values: diskio('+device+')' )
			sys.exit( 0 )

		# Get mtime of the interim file and calculate the sample period
		sample_period = float( time.time() - os.path.getmtime( interim_file ) )

		f1 = open( interim_file, 'r' )
		try:
			interim_content = f1.read()
		finally:
			f1.close()

		for line in interim_content.splitlines():
			if sep in line:
				interim_line = line.strip().split(sep)[1].split()
				break

		#compute deltas; refer: https://www.kernel.org/doc/Documentation/iostats.txt
		# each delta is divided by the sample period which gives us values in per second;
		d = {
			'read_operations': ( int( proc_line[0] ) - int( interim_line[0] ) ) / sample_period,
			'read_sectors':  ( int( proc_line[2] ) - int( interim_line[2] ) ) / sample_period,
			'read_time': ( int( proc_line[3] ) - int( interim_line[3] ) ) / sample_period,
			'write_operations': ( int( proc_line[4] ) - int( interim_line[4] ) ) / sample_period,
			'write_sectors': ( int( proc_line[6] ) - int( interim_line[6] ) ) / sample_period,
			'write_time': ( int( proc_line[7] ) - int( interim_line[7] ) ) / sample_period
		}

		status_outp += dev
		status_outp += '(' + device + ')'
		status_outp += ' Read: ' + str( '%.2f' % d['read_sectors'] ) + ' sec/s (' + str( '%.2f' % d['read_operations'] ) + ' t/s)'
		status_outp += ' Write: ' + str( '%.2f' % d['write_sectors'] ) + ' sec/s (' + str( '%.2f' % d['write_operations'] ) + ' t/s)'
		status_outp += ' [t:' + str( '%.2f' % sample_period ) + ']'

		if warn is not None and crit is not None:
			if float( d['read_sectors'] ) >= float( crit[0] ) or float( d['write_sectors'] ) >= float( crit[1] ):
				status_code = 2
				status_outp += ' (Critical)'
			elif float( d['read_sectors'] ) >= float( warn[0] ) or float( d['write_sectors'] ) >= float( warn[1] ):
				status_code = 1
				status_outp += ' (Warning)'
			else:
				status_code = 0
				status_outp += ' (OK)'
		else:
			status_code = 0
	
		for x in [ 'read_operations', 'read_sectors', 'read_time', 'write_operations', 'write_sectors', 'write_time' ]:
			perfdata += x + '=' + str( '%.2f' % d[x] ) 
			if warn is not None and crit is not None:
				if x == 'read_sectors':
					perfdata += ';' + str(warn[0]) + ';' + str(crit[0])
				elif x == 'write_sectors':
					perfdata += ';' + str(warn[1]) + ';' + str(crit[1])
			perfdata += ' '
		#remove last space
		perfdata = perfdata[:-1]
	
		#update the interim file
		shutil.copyfile( '/proc/diskstats', interim_file )
	
		print status_outp + ' | ' + perfdata
		sys.exit( status_code )

def check_disku( mount, warn=None, crit=None):
	status_code = 3
	status_outp =''
	perfdata = ''

	
	if os.path.ismount( mount ):
		statvfs = os.statvfs( mount )
	else:
		print ( 'Plugin Error: Mount point not valid: (' + mount + ')' )
		sys.exit( 3 )

	if statvfs is not None:
		du = {
		'size':  float( statvfs.f_frsize * statvfs.f_blocks / 1024.00 / 1024 / 1024 ),    # Size of filesystem
		'free':  float( statvfs.f_frsize * statvfs.f_bfree / 1024.00 / 1024 / 1024  ),    # Actual free
		'avail': float( statvfs.f_frsize * statvfs.f_bavail / 1024.00 / 1024 / 1024 )     # Available free
		}
		# Calculate Used percent
		du['used_pc'] = ( du['size'] - du['avail'] ) / du['size'] * 100

		status_outp += mount
		status_outp += ' Used: ' + str( '%.2f' % float( du['size'] - du['avail'] ) ) + ' GB / ' + str( '%.2f' % du['size'] ) + ' GB'
		status_outp += ' (' + str( '%.2f' % du['used_pc'] ) + '%)'

		if warn is not None and crit is not None:
			if du['used_pc'] >= float( crit ):
				status_code = 2
				status_outp += ' (Critical)'
			elif du['used_pc'] >= float( warn ):
				status_code = 1
				status_outp += ' (Warning)'
			else:
				status_code = 0
				status_outp += ' (OK)'
		else:
			status_code = 0
	
		perfdata += 'used=' + str( '%.2f' % du['used_pc'] ) + '%'
		if warn is not None and crit is not None:
			perfdata += ';' + str(warn) + ';' + str(crit)
	
		print status_outp + ' | ' + perfdata
		sys.exit( status_code )

def check_memory ( warn=None, crit=None ):
	status_code = 3
	status_outp =''
	perfdata = ''
	mem = {}
	f = open('/proc/meminfo', 'r')
	try:
		for line in f:
			if line.startswith( 'MemTotal: ' ):
				mem['total'] = int( line.split()[1] )
			elif line.startswith( 'Active: ' ):
				mem['active'] = int( line.split()[1] )
			elif line.startswith( 'MemFree: ' ):
				mem['free'] = int( line.split()[1] )
			elif line.startswith( 'Cached: ' ):
				mem['cached'] = int( line.split()[1] )
			elif line.startswith('Buffers: ' ):
				mem['buffers'] = int( line.split()[1] )
	finally:
		f.close()
	m = {
	'total':   float( mem['total'] / 1024.00 ),
	'active':  float( mem['active'] / 1024.00 ),
	'cached':  float( (mem['cached'] + mem['buffers']) / 1024.00 ),
	'used': float( (mem['total'] - mem['free'] - mem['cached'] - mem['buffers']) / 1024.00 ),
	'used_p': float( (mem['total'] - mem['free'] - mem['cached'] - mem['buffers']) ) / float( mem['total'] ) * 100.00
	}

	status_outp += 'Memory Used: ' + str( '%.2f' % m['used'] ) + 'MB / ' + str( '%.2f' % m['total'] ) + 'MB (' + str( '%.2f' % m['used_p'] ) + '%)'

	if warn is not None and crit is not None:
		if m['used_p'] >= float( crit ):
			status_code = 2
			status_outp += ' (Critical)'
		elif m['used_p'] >= float( warn ):
			status_code = 1
			status_outp += ' (Warning)'
		else:
			status_code = 0
			status_outp += ' (OK)'
	else:
		status_code = 0

	for x in [ 'used', 'cached', 'active' ]:
		perfdata += x + '=' + str( '%.2f' % m[x] )
		if x == 'used':
			if warn is not None and crit is not None:
				warn_mb = int( m['total'] * float( warn ) / 100 )
				crit_mb = int( m['total'] * float( crit ) / 100 )
				perfdata += ';' + str( warn_mb ) + ';' + str( crit_mb )
			else:
				perfdata += ';;'
			perfdata += ';0;' + str( int( m['total'] ) )
		perfdata += ' '
	#remove last space
	perfdata = perfdata[:-1]

	print status_outp + ' | ' + perfdata
	sys.exit( status_code )

def check_swap ( warn=None, crit=None ):
	status_code = 3
	status_outp =''
	perfdata = ''
	swap = {}

	f = open('/proc/meminfo', 'r')
	try:
		for line in f:
			if line.startswith('SwapTotal: ' ):
				swap['total'] = int( line.split()[1] )
			elif line.startswith('SwapFree: ' ):
				swap['free'] = int( line.split()[1] )
			elif line.startswith('SwapCached: ' ):
				swap['cached'] = int( line.split()[1] )
	finally:
		f.close()
	s = {
	'total':   float( swap['total'] / 1024.00 ),
	'cached':  float( swap['cached'] / 1024.00 ),
	'used':    float( (swap['total'] - swap['free'] - swap['cached']) / 1024.00 ),
	'used_p':  float( swap['total'] - swap['free'] - swap['cached'] ) / swap['total'] * 100.00
	}

	status_outp += 'Swap Used: ' + str( '%.2f' % s['used'] ) + 'MB / ' + str( '%.2f' % s['total'] ) + 'MB (' + str( '%.2f' % s['used_p'] ) + '%)'

	if warn is not None and crit is not None:
		if s['used_p'] >= float( crit ):
			status_code = 2
			status_outp += ' (Critical)'
		elif s['used_p'] >= float( warn ):
			status_code = 1
			status_outp += ' (Warning)'
		else:
			status_code = 0
			status_outp += ' (OK)'
	else:
		status_code = 0
	for x in [ 'used', 'cached' ]:
		perfdata += x + '=' + str( '%.2f' % s[x] )
		if x == 'used':
			if warn is not None and crit is not None:
				warn_mb = int( s['total'] * float( warn ) / 100 )
				crit_mb = int( s['total'] * float( crit ) / 100 )
				perfdata += ';' + str( warn_mb ) + ';' + str( crit_mb )
			else:
				perfdata += ';;'
			perfdata += ';0;' + str( int( s['total'] ) )
		perfdata += ' '
	#remove last space
	perfdata = perfdata[:-1]

	print status_outp + ' | ' + perfdata
	sys.exit( status_code )

def check_net ( interface, warn=None, crit=None ):
	status_code = 0
	status_outp =''
	perfdata = ''

	#Verify if the interim file exists, if not create it now
	interim_file = INTERIM_DIR + '/' + 'proc_net_dev_' + interface
	if not os.path.isfile( interim_file ):
		shutil.copyfile( '/proc/net/dev', interim_file )
		print ( 'This was the first run, run again to get values: net:' + interface )
		sys.exit( 0 )

	# Get mtime of the interim file and calculate the sample period
	sample_period = float ( time.time() - os.path.getmtime( interim_file ) )

	# Calculate the deltas
	int_t = {}
	int_d = {}
	for file in ['/proc/net/dev', interim_file]:
		f = open( file, 'r' )
		try:
			for line in f:
				line = line.strip()
				if line.startswith( interface+':' ):
					seq = 0
					for x in ['r_bytes','r_packets','r_errs','r_drop','r_fifo','r_frame','r_compressed','r_multicast',
						't_bytes','t_packets','t_errs','t_drop','t_fifo','t_colls','t_carrier','t_compressed']:
						# if files is current/proc, load values in int_t
						if file == '/proc/net/dev':
							int_t[x] = int( line.split( interface+':' )[1].split()[seq] )
						# if file is interim calculate the diff and load deltas in int_d
						elif file == interim_file:
							interim_value = int( line.split( interface+':' )[1].split()[seq] )
							int_d[x] = int_t[x] - interim_value
						seq += 1
					break
		finally:
			f.close()
	if not int_t or not int_d:
		#interface not found
		print ( 'Plugin Error: Network device not found: ('+interface+')' )
		sys.exit( 3 )
	else:
		int_d['RX_MBps'] = float( int_d['r_bytes'] / 1024.00 / 1024.00 / sample_period )
		int_d['TX_MBps'] = float( int_d['t_bytes'] / 1024.00 / 1024.00 / sample_period )
		int_d['RX_PKps'] = float( int_d['r_packets'] / sample_period )
		int_d['TX_PKps'] = float( int_d['t_packets'] / sample_period )

		status_outp += interface
		status_outp += ' Rx: ' + str( '%.2f' % int_d['RX_MBps'] ) + ' MB/s (' + str( '%.2f' % int_d['RX_PKps'] ) + ' p/s)'
		status_outp += ' Tx: ' + str( '%.2f' % int_d['TX_MBps'] ) + ' MB/s (' + str( '%.2f' % int_d['TX_PKps'] ) + ' p/s)'
		status_outp += ' [t:' + str( '%.2f' % sample_period ) + ']'

		# Check packet errors
		int_d['PK_ERRORS'] = 0
		for x in ['r_errs','r_drop','r_fifo','r_frame',
			't_errs','t_drop','t_fifo','t_colls','t_carrier']:
			if float( int_d[x] ) > 0:
				int_d['PK_ERRORS'] += int_d[x]
				status_code = 2
				status_outp += ' (Critical ' + x + ':' + str(int_d[x]) + ')'
		# Skip bw checks if packer error
		if warn is not None and crit is not None and int_d['PK_ERRORS'] == 0:
			if float( int_d['RX_MBps'] ) >= float( crit[0] ) or float( int_d['TX_MBps'] ) >= float( crit[1] ):
				status_code = 2
				status_outp += ' (Critical BW)'
			elif float( int_d['RX_MBps'] ) >= float( warn[0] ) or float( int_d['TX_MBps'] ) >= float( warn[1] ):
				if status_code < 1:
					status_code = 1
				status_outp += ' (Warning BW)'
			else:
				status_outp += ' (OK)'

		for x in [ 'RX_MBps', 'RX_PKps', 'TX_MBps', 'TX_PKps', 'PK_ERRORS']:
			perfdata += x + '=' + str( '%.2f' % int_d[x] ) 
			if warn is not None and crit is not None :
				if x == 'RX_MBps':
					perfdata += ';' + str(warn[0]) + ';' + str(crit[0])
				elif x == 'TX_MBps':
					perfdata += ';' + str(warn[1]) + ';' + str(crit[1])
			perfdata += ' '
		#remove last space
		perfdata = perfdata[:-1]

		#update the interim file
		shutil.copyfile( '/proc/net/dev', interim_file )

		print status_outp + ' | ' + perfdata
		sys.exit( status_code )


def copy_interface_data ( filein, fileout, interface):
	f = open( filein, 'r' )
	f1 = open( fileout, 'w' )
	try:
		for line in f:
			line = line.strip()
			if line.startswith( interface+':' ):
				f1.write(line)
				break
	finally:
		f.close()
		f1.close()

def check_network_bandwidth ( interface, warn=None, crit=None ):
	interface_found = 0
	status_code = 0
	status_outp =''
	status_message ='(OK)'
	perfdata = ''

	#Verify if the interim file exists, if not create it now
	interim_file = INTERIM_DIR + '/' + 'proc_net_dev_bw_' + interface
	if not os.path.isfile( interim_file ):
		file = '/proc/net/dev'
		f = open( file, 'r' )
		try:
			for line in f:
				line = line.strip()
				if line.startswith( interface+':' ):
					interface_found = 1
					break
		finally:
			f.close()

		if interface_found == 0:
			print ( 'Network device not found for interface '+interface )
			sys.exit( 3 )

		copy_interface_data('/proc/net/dev', interim_file, interface)
		print ( 'This was the first run, run again to get values for interface ' + interface )
		sys.exit( 1 )

	# Get mtime of the interim file and calculate the sample period
	sample_period = float ( time.time() - os.path.getmtime( interim_file ) )

	# Calculate the deltas
	int_t = {}
	int_d = {}
	for file in ['/proc/net/dev', interim_file]:
		f = open( file, 'r' )
		try:
			for line in f:
				line = line.strip()
				if line.startswith( interface+':' ):
					seq = 0
					for x in ['r_bytes','r_packets','r_errs','r_drop','r_fifo','r_frame','r_compressed','r_multicast',
						't_bytes','t_packets','t_errs','t_drop','t_fifo','t_colls','t_carrier','t_compressed']:
						# if files is current/proc, load values in int_t
						if file == '/proc/net/dev':
							int_t[x] = int( line.split( interface+':' )[1].split()[seq] )
						# if file is interim calculate the diff and load deltas in int_d
						elif file == interim_file:
							interim_value = int( line.split( interface+':' )[1].split()[seq] )
							int_d[x] = int_t[x] - interim_value
						seq += 1
					break
		finally:
			f.close()

#   Zero length interim file results in network device not found.  Should
#   just handle it the same as a first run and continue.
	if not int_t:
		#interface not found in /proc/net/dev
		print ( 'Plugin Error: Network device not found: ('+interface+')' )
		sys.exit( 3 )

	elif not int_d:
		#interface not found in interim file
		copy_interface_data('/proc/net/dev', interim_file, interface)
		print ( 'Rebuilding missing interim file, run again to get values for interface ' + interface )
		sys.exit( 1 )

	else:
		try:
			f = open( '/sys/class/net/'+interface+'/speed', 'r' )
			for line in f:
				speed = int(line.strip()) / 8
				break
		finally:
			f.close()

		try:
			f = open( '/sys/class/net/'+interface+'/duplex', 'r' )
			for line in f:
				duplex = line.strip()
				break
		finally:
			f.close()
		try:
			f = open( '/sys/class/net/'+interface+'/mtu', 'r' )
			for line in f:
				mtu = line.strip()
				break
		finally:
			f.close()

		int_d['RX_MBps'] = float( int_d['r_bytes'] / 1024.00 / 1024.00 / sample_period )
		if int_d['RX_MBps'] < 0:
			copy_interface_data('/proc/net/dev', interim_file, interface)
			print ( 'System restart since last check, run again to get values for interface ' + interface )
			sys.exit( 0 )
		
		int_d['TX_MBps'] = float( int_d['t_bytes'] / 1024.00 / 1024.00 / sample_period )
		int_d['RX_Util'] = float( (int_d['RX_MBps'] / speed) * 100 )
		int_d['TX_Util'] = float( (int_d['TX_MBps'] / speed) * 100 )
		int_d['Total_Util'] = float( ( (int_d['RX_MBps'] + int_d['TX_MBps'] ) / speed ) * 100 )

		status_outp += 'Interface: ' + interface + ' '
		status_outp += ' Speed: ' + str( '%d' % speed ) + ' MB/sec '
		status_outp += ' Duplex: ' + str( '%s ' % duplex )
		status_outp += ' MTU: ' + str( '%s ' % mtu )
		status_outp += ' Rx: ' + str( '%.2f' % int_d['RX_MBps'] ) + ' MB/sec '
		if duplex == 'full':
			status_outp += '(' + str( '%.2f' % int_d['RX_Util'] ) + '%) '
		status_outp += ' Tx: ' + str( '%.2f' % int_d['TX_MBps'] ) + ' MB/sec '
		if duplex == 'full':
			status_outp += '(' + str( '%.2f' % int_d['TX_Util'] ) + '%) '
		status_outp += ' Total: ' + str( '%.2f' % (int_d['TX_MBps'] + int_d['RX_MBps']) ) + ' MB/sec '
		if duplex != 'full':
			status_outp += '(' + str( '%.2f' % int_d['Total_Util'] ) + '%) '
		status_outp += ' [' + str( '%.2f' % sample_period ) + ' seconds]'

		# Calculate the current bandwidth status
		if warn is not None and crit is not None:
			if duplex == 'full':
				if float( int_d['RX_Util'] ) >= float( crit ) or float( int_d['TX_Util'] ) >= float( crit ):
					status_code = 2
					status_message = '(Critical)'
				elif float( int_d['RX_Util'] ) >= float( warn ) or float( int_d['TX_Util'] ) >= float( warn ):
					status_code = 1
					status_message = '(Warning)'
			else:
				if float( int_d['RX_Util'] ) + float( int_d['TX_Util'] ) >= float( crit ):
					status_code = 2
					status_message = '(Critical)'
				elif float( int_d['RX_Util'] ) + float( int_d['TX_Util'] ) >= float( warn ):
					status_code = 1
					status_message = '(Warning)'
			
		# Add performance data to the output
		for x in [ 'RX_MBps', 'RX_Util', 'TX_MBps', 'TX_Util']:
			if x == 'RX_MBps' or x == 'TX_MBps':
				perfdata += x + '=' + str( '%.2f' % int_d[x] ) + 'MBps'
			elif duplex == 'full':
				perfdata += x + '=' + str( '%.2f' % int_d[x] ) + '%'
				if warn is not None and crit is not None :
					perfdata += ';' + str(warn) + ';' + str(crit)
			perfdata += ' '
		perfdata += 'total_MBps=' + str( '%.2f' % (int_d['TX_MBps'] + int_d['RX_MBps']) ) + 'MBps'
		if duplex != 'full':
			perfdata += ' Total_Util=' + str( '%.2f' % int_d['Total_Util'] ) + '%'
			if warn is not None and crit is not None:
				perfdata += ';' + str(warn) + ';' + str(crit)
			
		# update the interim file
		copy_interface_data('/proc/net/dev', interim_file, interface)

		print status_message + ' ' + status_outp + '|' + perfdata
		sys.exit( status_code )

def check_network_error ( interface, warn=None, crit=None ):
	interface_found = 0
	status_code = 0
	status_outp =''
	error_detail=''
	status_message ='(OK)'
	perfdata = ''

	# Verify if the interim file exists, if not create it now
	interim_file = INTERIM_DIR + '/' + 'proc_net_dev_err_' + interface
	if not os.path.isfile( interim_file ):
		file = '/proc/net/dev'
		f = open( file, 'r' )
		try:
			for line in f:
				line = line.strip()
				if line.startswith( interface+':' ):
					interface_found = 1
					break
		finally:
			f.close()

		if interface_found == 0:
			print ( 'Network device not found for interface '+interface )
			sys.exit( 3 )

		copy_interface_data('/proc/net/dev', interim_file, interface)
		print ( 'This was the first run, run again to get values: net:' + interface )
		sys.exit( 1 )

	# Get mtime of the interim file and calculate the sample period
	sample_period = float ( time.time() - os.path.getmtime( interim_file ) )

	# Calculate the deltas
	int_t = {}
	int_d = {}
	for file in ['/proc/net/dev', interim_file]:
		f = open( file, 'r' )
		try:
			for line in f:
				line = line.strip()
				if line.startswith( interface+':' ):
					seq = 0
					for x in ['rx_bytes','rx_packets','rx_pkt_errors','rx_pkt_drop',
					    'rx_pkt_fifo','rx_pkt_frame','rx_pkt_compressed','rx_pkt_multicast',
						'tx_bytes','tx_packets','tx_pkt_errors','tx_pkt_drop',
						'tx_pkt_fifo','tx_pkt_collisions','tx_pkt_carrier','tx_pkt_compressed']:
						# if files is current/proc, load values in int_t
						if file == '/proc/net/dev':
							int_t[x] = int( line.split( interface+':' )[1].split()[seq] )
						# if file is interim calculate the diff and load deltas in int_d
						elif file == interim_file:
							interim_value = int( line.split( interface+':' )[1].split()[seq] )
							int_d[x] = int_t[x] - interim_value
						seq += 1
					break
		finally:
			f.close()

	# Zero length interm file results in network device not found.  Should
	# just handle it the same as a first run and continue.
	if not int_t:
		#interface not found in /proc/net/dev
		print ( 'Plugin Error: Network device not found: ('+interface+')' )
		sys.exit( 3 )

	elif not int_d:
		#interface not found in interim file
		copy_interface_data('/proc/net/dev', interim_file, interface)
		print ( 'Rebuilding missing interim file, run again to get values for interface ' + interface )
		sys.exit( 1 )

	else:
		status_outp += 'Interface: ' + interface
		int_d['PK_ERRORS'] = 0

		# Add receive base data
		int_d['ERROR_RATE'] = round( float( int_d['rx_pkt_errors'] / ( sample_period / 60 ) ), 2 )
		if int_d['ERROR_RATE'] < 0:
			copy_interface_data('/proc/net/dev', interim_file, interface)
			print ( 'System restart since last check, run again to get values for interface ' + interface )
			sys.exit( 0 )
		
		status_outp += ' Rx: ' + str(int_d['ERROR_RATE']) + ' epm'
		perfdata += 'rx_pkt_errors=' + str(int_d['ERROR_RATE'])  + 'epm'
		if warn is not None and crit is not None:
			perfdata += ';' + str(warn) + ';' + str(crit)

		int_d['ERROR_RATE'] = round( float( int_d['rx_packets'] / 1024 / ( sample_period / 60 ) ), 2 )
		status_outp += ' ' + str(int_d['ERROR_RATE']) + ' Kppm'
		perfdata += ' rx_packets=' + str(int_d['ERROR_RATE'])  + 'Kppm'

		# If there are receive errors, add rx data
		error_detail = ''
		for x in ['rx_pkt_drop','rx_pkt_fifo','rx_pkt_frame']:
			int_d['ERROR_RATE'] = round( float( int_d[x] / ( sample_period / 60 ) ), 2 )
			if float( int_d[x] ) > 0:
				error_detail += x + ':' + str(int_d['ERROR_RATE'])  + ' epm '

		if float( int_d['rx_pkt_errors'] ) > 0:
			status_outp += ' (' + error_detail.strip() + ')'

		# Add transmit base data
		int_d['ERROR_RATE'] = round( float( int_d['tx_pkt_errors'] / ( sample_period / 60 ) ), 2 )
		status_outp += ' Tx: ' + str(int_d['ERROR_RATE'])  + ' epm'
		perfdata += ' tx_pkt_errors=' + str(int_d['ERROR_RATE'])  + 'epm'
		if warn is not None and crit is not None:
			perfdata += ';' + str(warn) + ';' + str(crit)

		int_d['ERROR_RATE'] = round( float( int_d['tx_packets'] / 1024 / ( sample_period / 60 ) ), 2 )
		status_outp += ' ' + str(int_d['ERROR_RATE']) + ' Kppm'
		perfdata += ' tx_packets=' + str(int_d['ERROR_RATE'])  + 'Kppm'

		# If there are transmit errors, add tx data
		error_detail = ''
		for x in ['tx_pkt_drop','tx_pkt_fifo','tx_pkt_collisions','tx_pkt_carrier']:
			int_d['ERROR_RATE'] = round( float( int_d[x] / ( sample_period / 60 ) ), 2 )
			if float( int_d[x] ) > 0:
				error_detail += x + ':' + str(int_d['ERROR_RATE'])  + ' epm '

		if float( int_d['tx_pkt_errors'] ) > 0:
			status_outp += ' (' + error_detail.strip() + ')'

		# If thresholds have been set and errors occurred, check to
		# see what status to report (critical, warning, or OK)
		int_d['PK_ERRORS'] = round( float ( ( int_d['rx_pkt_errors'] + int_d['tx_pkt_errors'] ) / ( sample_period / 60 ) ), 2 )
		if warn is not None and crit is not None:
			if float( int_d['PK_ERRORS'] ) >= float( crit ):
				status_code = 2
				status_message = '(Critical)'
			elif float( int_d['PK_ERRORS'] ) >= float( warn ):
				status_code = 1
				status_message = '(Warning)'
			
		# Include the aggregate error count in the output
		status_outp += ' Total: ' + str(int_d['PK_ERRORS']) + ' epm'
		perfdata += ' total_errors=' + str(int_d['PK_ERRORS']) + 'epm'
		if warn is not None and crit is not None:
			perfdata += ';' + str(warn) + ';' + str(crit)

		int_d['PK_ERRORS'] = round( float ( ( int_d['rx_packets'] + int_d['tx_packets'] ) / 1024 / ( sample_period / 60 ) ), 2 )
		status_outp += ' ' + str(int_d['PK_ERRORS']) + ' Kppm'
		perfdata += ' total_packets=' + str(int_d['PK_ERRORS']) + 'Kppm'
		status_outp += ' [' + str( '%.2f' % sample_period ) + ' seconds]'

		# update the interim file
		copy_interface_data('/proc/net/dev', interim_file, interface)
		print status_message + ' ' + status_outp + '|' + perfdata
		sys.exit( status_code )


#####################
# Mainline function #
#####################
if __name__ == '__main__':

	if len( sys.argv ) > 1:
		# cpu warn crit sample
		if sys.argv[1] == 'cpu':
			# no arg passed after cpu
			if len( sys.argv ) == 2:
				check_cpu()
			# 2 args passed after cpu; warn,crit
			elif len( sys.argv ) == 4:
				if float( sys.argv[3] ) > float( sys.argv[2] ):
					check_cpu( warn=sys.argv[2], crit=sys.argv[3] )
				else:
					print ( 'Plugin Error: Warning('+sys.argv[2]+') threshold should be less than critical('+sys.argv[3]+')' )
					sys.exit( 3 )
			else:
				print ( 'Plugin Error: Invalide arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )
	
		# procs
		elif sys.argv[1] == 'procs':
			# no arg passed after procs
			if len( sys.argv ) == 2:
				check_procs()
			# if 2 args passed after procs
			elif len( sys.argv ) == 4:
				#process comma separated arguments
				warn_arr = sys.argv[2].split(',')
				crit_arr = sys.argv[3].split(',')
				if len(warn_arr) > 3 or len(warn_arr) < 1 or len(warn_arr) != len(crit_arr):
					print ( 'Plugin Error: Invalide arguments for load: ('+str(sys.argv)+')' )
					sys.exit( 3 )
				else:
					for i in range( len( warn_arr ) ):
						if warn_arr[i] != '' and crit_arr[i] != '':
							if float(warn_arr[i]) > float(crit_arr[i]):
								print ( 'Plugin Error: Warning('+warn_arr[i]+') threshold should be less than critical('+crit_arr[i]+')' )
								sys.exit( 3 )
					check_procs( warn=warn_arr, crit=crit_arr )
			else:
				print ( 'Plugin Error: Invalide arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )
				
		# load
		elif sys.argv[1] == 'load':
			# no arg passed after load
			if len( sys.argv ) == 2:
				check_load()
			# if 2 args passed after load
			elif len( sys.argv ) == 4:
				#process comma separated arguments
				warn_arr = sys.argv[2].split(',')
				crit_arr = sys.argv[3].split(',')
				if len(warn_arr) > 3 or len(warn_arr) < 1 or len(warn_arr) != len(crit_arr):
					print ( 'Plugin Error: Invalide arguments for load: ('+str(sys.argv)+')' )
					sys.exit( 3 )
				else:
					for i in range( len( warn_arr ) ):
						if warn_arr[i] != '' and crit_arr[i] != '':
							if float(warn_arr[i]) > float(crit_arr[i]):
								print ( 'Plugin Error: Warning('+warn_arr[i]+') threshold should be less than critical('+crit_arr[i]+')' )
								sys.exit( 3 )
					check_load( warn=warn_arr, crit=crit_arr )
			else:
				print ( 'Plugin Error: Invalide arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )

		# threads
		elif sys.argv[1] == 'threads':
			# no arg passed after procs
			if len( sys.argv ) == 2:
				check_threads()
			# if 2 args passed after procs
			elif len( sys.argv ) == 4:
				if float( sys.argv[3] ) > float( sys.argv[2] ):
					check_threads( warn=sys.argv[2], crit=sys.argv[3] )
				else:
					print ( 'Plugin Error: Warning('+sys.argv[2]+') threshold should be less than critical('+sys.argv[3]+')' )
					sys.exit( 3 )
			else:
				print ( 'Plugin Error: Invalide arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )
				
		# Open files
		elif sys.argv[1] == 'files':
			# no arg passed after procs
			if len( sys.argv ) == 2:
				check_openfiles()
			# if 2 args passed after procs
			elif len( sys.argv ) == 4:
				if float( sys.argv[3] ) > float( sys.argv[2] ):
					check_openfiles( warn=sys.argv[2], crit=sys.argv[3] )
				else:
					print ( 'Plugin Error: Warning('+sys.argv[2]+') threshold should be less than critical('+sys.argv[3]+')' )
					sys.exit( 3 )
			else:
				print ( 'Plugin Error: Invalide arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )

		# diskio dev warn(read,write) crit(read,write)
		elif sys.argv[1] == 'diskio':
			# no arg passed after diskio [dev]
			if len( sys.argv ) == 3:
				check_diskio( sys.argv[2] )
			# if 2 args passed after diskio [dev]
			elif len( sys.argv ) == 5:
				#process comma separated arguments
				#we convert it to an array and pass it on
				warn_arr = sys.argv[3].split(',')
				crit_arr = sys.argv[4].split(',')
				if len(warn_arr) != 2 or len(warn_arr) != len(crit_arr):
					print ( 'Plugin Error: Invalide arguments for ' + sys.argv[1] + ': ('+str(sys.argv)+')' )
					sys.exit( 3 )
				else:
					for i in range( len( warn_arr ) ):
						if float(warn_arr[i]) > float(crit_arr[i]):
							print ( 'Plugin Error: Warning('+warn_arr[i]+') threshold should be less than critical('+crit_arr[i]+')' )
							sys.exit( 3 )
					check_diskio( sys.argv[2], warn=warn_arr, crit=crit_arr )
			else:
				print ( 'Plugin Error: Invalide arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )

		# disku mount warn crit
		elif sys.argv[1] == 'disku':
			# no arg passed after disku mount
			if len( sys.argv ) == 3:
				check_disku( sys.argv[2] )
			# if 2 args passed after disku mount
			elif len( sys.argv ) == 5:
				if float( sys.argv[4] ) > float ( sys.argv[3] ):
					check_disku( sys.argv[2] , warn=sys.argv[3], crit=sys.argv[4] )
				else:
					print ( 'Plugin Error: Warning('+sys.argv[2]+') threshold should be less than critical('+sys.argv[3]+')' )
					sys.exit( 3 )
			else:
				print ( 'Plugin Error: Invalide arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )

		# memory warn crit
		elif sys.argv[1] == 'memory':
			# no arg passed after memory
			if len( sys.argv ) == 2:
				check_memory()
			# if 2 args passed after memory
			elif len( sys.argv ) == 4:
				if float( sys.argv[3] ) > float( sys.argv[2] ):
					check_memory( warn=sys.argv[2] , crit=sys.argv[3] )
				else:
					print ( 'Plugin Error: Warning('+sys.argv[2]+') threshold should be less than critical('+sys.argv[3]+')' )
					sys.exit( 3 )
			else:
				print ( 'Plugin Error: Invalide arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )

		# swap warn crit
		elif sys.argv[1] == 'swap':
			# no arg passed after swap
			if len( sys.argv ) == 2:
				check_swap()
			# if 2 args passed after swap
			elif len( sys.argv ) == 4:
				if float( sys.argv[3] ) > float( sys.argv[2] ):
					check_swap( warn=sys.argv[2] , crit=sys.argv[3] )
				else:
					print ( 'Plugin Error: Warning('+sys.argv[2]+') threshold should be less than critical('+sys.argv[3]+')' )
					sys.exit( 3 )
			else:
				print ( 'Plugin Error: Invalide arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )
	
		# network iface warn(rx,tx)  crit(rx,tx)
		elif sys.argv[1] == 'network':
			# no arg passed after network iface
			if len( sys.argv ) == 3:
				check_net( sys.argv[2] )
			# if 2 args passed after network iface
			elif len( sys.argv ) == 5:
				#process comma separated arguments
				#we convert it to an array and pass it on
				warn_arr = sys.argv[3].split(',')
				crit_arr = sys.argv[4].split(',')
				if len(warn_arr) != 1 or len(warn_arr) != len(crit_arr):
					print ( 'Plugin Error: Invalid arguments for ' + sys.argv[1] + ': ('+str(sys.argv)+')' )
					sys.exit( 3 )
				else:
					for i in range( len( warn_arr ) ):
						if float(warn_arr[i]) > float(crit_arr[i]):
							print ( 'Plugin Error: Warning('+warn_arr[i]+') threshold should be less than critical('+crit_arr[i]+')' )
							sys.exit( 3 )
					check_net( sys.argv[2], warn=warn_arr, crit=crit_arr )
			else:
				print ( 'Plugin Error: Invalid arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )
	
		# network iface bandwidth warn(rx,tx)  crit(rx,tx)
		elif sys.argv[1] == 'network_bandwidth':
			# no arg passed after network iface
			if len( sys.argv ) == 3:
				check_network_bandwidth( sys.argv[2] )
			# if 2 args passed after network iface
			elif len( sys.argv ) == 5:
				if float( sys.argv[4] ) > float( sys.argv[3] ):
					check_network_bandwidth( sys.argv[2], warn=sys.argv[3], crit=sys.argv[4] )
				else:
					print ( 'Plugin Error: Critical theshold < warning threshold for ' + sys.argv[1] + ': ('+str(sys.argv)+')' )
					sys.exit( 3 )
			else:
				print ( 'Plugin Error: Invalid arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )
	
		# network iface errors warn (count)  crit(count)
		elif sys.argv[1] == 'network_error':
			# no arg passed after network iface
			if len( sys.argv ) == 3:
				check_network_error( sys.argv[2] )
			# if 2 args passed after network iface
			elif len( sys.argv ) == 5:
				if float( sys.argv[4] ) > float( sys.argv[3] ):
					check_network_error( sys.argv[2], warn=sys.argv[3], crit=sys.argv[4] )
				else:
					print ( 'Plugin Error: Critical theshold < warning threshold for ' + sys.argv[1] + ': ('+str(sys.argv)+')' )
					sys.exit( 3 )
			else:
				print ( 'Plugin Error: Invalid arguments for '+sys.argv[1]+': ('+str(sys.argv)+')' )
				sys.exit( 3 )
		else:
			print ( 'What?' )
			sys.exit( 3 )
